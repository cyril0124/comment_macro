use clap::Parser;
use mlua::prelude::*;
use regex::Regex;
use std::collections::hash_map::DefaultHasher;
use std::{
    hash::{Hash, Hasher},
    path::PathBuf,
};

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    file: Vec<String>,

    #[arg(short = 'f', long, help = "Input filelist")]
    filelist: Vec<String>,

    #[arg(short, long, help = "Output directory")]
    outdir: Option<String>,

    #[arg(short = 'F', long, action = clap::ArgAction::SetTrue, help = "Force enable comment_macro(ignore the first line comment of the input file)")]
    force_enable: Option<bool>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = Args::parse();

    // Extract input files
    let mut input_files: Vec<String> = Vec::new();
    if !args.file.is_empty() {
        input_files.append(&mut args.file);
    }
    if !args.filelist.is_empty() {
        for filelist in &args.filelist {
            let filelist = std::fs::read_to_string(filelist)?;
            for line in filelist.lines() {
                input_files.push(line.to_string());
            }
        }
    }

    assert!(!input_files.is_empty(), "No input file specified");

    // Calculate output directory
    let hash_value = {
        let mut s = DefaultHasher::new();
        input_files.concat().hash(&mut s);
        s.finish()
    };
    let outdir = args
        .outdir
        .unwrap_or(String::from(format!("/tmp/comment_macro{}", hash_value)));

    let lua = unsafe { Lua::unsafe_new() };

    // Load all standard libraries
    lua.load_std_libs(mlua::StdLib::ALL).unwrap();

    // Load macro_engine.lua
    lua.load(include_str!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/src/lua/macro_engine.lua"
    )))
    .set_name("macro_engine.lua")
    .exec()
    .unwrap();

    // Use to get output content from the lua code
    let get_output: LuaFunction = lua.globals().get("get_output").unwrap();

    // Check if the generated code should be squeezed into one line
    let check_keep_line: LuaFunction = lua.globals().get("_check_keep_line").unwrap();

    let mut output_files: Vec<String> = Vec::new();
    let mut process_file = |ext: &str, file: &str, file_name: &str| {
        let (re, mark, processed_mark) = match ext {
            // Rust, C/C++, Verilog/SystemVerilog
            //
            // /*lua*
            // <Your lua code>
            // *lua*/
            //
            "rs" | "cpp" | "cc" | "c" | "v" | "sv" | "svh" => (
                Regex::new(r"(?s)/\*lua\*\s*(.*?)\s*\*lua\*/").unwrap(),
                "*lua*",
                "*lua-processed*",
            ),

            // Python
            // 
            // '''*lua*
            // <Your lua code>
            // *lua*'''
            // 
            "py" => (
                Regex::new(r"(?s)'''\*lua\*(.*?)\*lua\*'''").unwrap(),
                "*lua*",
                "*lua-processed*",
            ),

            // Lua
            //
            // --[===[*lua*
            // <Your lua code>
            // *lua*]===]
            //
            "lua" => (
                Regex::new(r"(?s)--\[===\[\*lua\*(.*?)\*lua\*\]===\]").unwrap(),
                "*lua*",
                "*lua-processed*",
            ),

            // Others languages ...
            _ => panic!("Unsupported file extension: {}", ext),
        };

        // Read first line of file
        let mut content = std::fs::read_to_string(&file)
            .expect(format!("Failed to read file: {}", file).as_str());
        let first_line = content.lines().next().unwrap();

        if first_line.contains("comment_macro") || args.force_enable.unwrap_or(false) {
            // Replace `__code_name__` with the file name
            let code_name = file_name;
            lua.globals().set("__code_name__", code_name).unwrap();

            while let Some(cap) = re.captures(&content) {
                let code = &cap[1];
                let mut lua_result = match lua.load(code).eval::<mlua::Value>() {
                    Ok(value) => match value {
                        mlua::Value::String(s) => s.to_str().unwrap().to_owned(),
                        mlua::Value::Nil => "".to_owned(),
                        _ => panic!(
                            "Expected string bug got {:?}\n----------\n{}\n----------",
                            value, code
                        ),
                    },
                    Err(err) => panic!(
                        "Error evaluating lua code, {}\n----------\n{}\n----------",
                        err, code
                    ),
                };

                // Code generated by `output/out/o/outputf/outf/of` will be saved in `output_str`
                let output_str: String = get_output.call::<String>(()).unwrap();
                lua_result = output_str + " " + lua_result.as_str();

                let keep_line: bool = check_keep_line.call::<bool>(()).unwrap();
                if !keep_line {
                    lua_result = lua_result.replace("\n", " ");
                }

                content = content.replacen(
                    &cap[0],
                    &format!("{} {}", &cap[0].replace(mark, processed_mark), &lua_result),
                    1,
                );
            }
        }

        // Write output file to target directory
        let output_file = format!("{}/{}", outdir, file_name);
        std::fs::create_dir_all(&outdir)
            .expect(format!("Failed to create directory: {}", outdir).as_str());
        std::fs::write(&output_file, content)
            .expect(format!("Failed to write file: {}", output_file).as_str());

        output_files.push(output_file);
    };

    for file in input_files {
        let file_ext = file.split(".").last().unwrap();
        let file_path = PathBuf::from(&file);
        let file_name = file_path.file_name().unwrap().to_str().unwrap();
        lua.globals()
            .set("curr_dir", file_path.parent().unwrap())
            .unwrap();
        process_file(file_ext, &file, &file_name);
    }

    if output_files.len() == 1 {
        print!("{}", output_files[0]);
    } else {
        print!("{}", output_files.join(" "));
    }

    Ok(())
}
